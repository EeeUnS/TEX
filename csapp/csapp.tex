%!TEX encoding = UTF-8 Unicode

%\documentclass{report}
%\usepackage[cjk]{kotex}

\documentclass{memoir}
\usepackage[cjk]{kotex}


%\usepackage{ikps,ansform}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{lipsum}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{ansform}
\usepackage{thmtools}
\usepackage{graphicx}
%https://www.overleaf.com/learn/latex/Inserting_Images

\usepackage{listings}
\usepackage{xcolor}
\declaretheoremstyle[% spaceabove=6pt,spacebelow=6pt, headfont=\color{MainColorOne}\sffamily\bfseries, notefont=\mdseries, notebraces={[}{]}, bodyfont=\normalfont,
headpunct={},
postheadspace=1em,
%qed=▣,
]{maintheorem}

\declaretheorem[%
name=정의,
style=maintheorem,
numberwithin=chapter, shaded={%bgcolor=MainColorThree!20,
margin=.5em}]{dfn}
% \begin{dfn}[]
% \end{dfn}

\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
%https://www.overleaf.com/learn/latex/Theorems_and_proofs

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
%https://tex.stackexchange.com/questions/348651/c-code-to-add-in-the-document
\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
\usepackage{bookmark}

\bookmarksetup{startatroot}


\begin{document}
    
\title{CSAPP}
\author{ EUnS }

\maketitle

\tableofcontents


\include{section12}


\chapter{Machine-Level Representation of Programs}


linux> gcc -Og -o p p1.c p2.c


-0g 옵션 : 최적화 x

ISA (instruction set architectune)

linux> gcc -Og -S mstore.c

-S : 어셈블리 코드만 만든다 .s

linux> gcc -Og -c mstore.c

바이너리 형식 목적파일 .o  생성


linux> objdump -d mstore.o

disassembly


\section{x86 assembly}


% \begin{figure}[h!]
%     \centering
% %    \includegraphics[scale=0.5]{pic/section12/pit1}
%     \caption{ward 0x1234567이 저장되는 방식.}
% \end{figure}




% \begin{figure}[h!]
%     \centering
%     \includegraphics[scale=0.5]{pic/section12/pit1}
%     \caption{ward 0x1234567이 저장되는 방식.}
% \end{figure}





3.1 A Historical Perspective 202
3.2 Program Encodings 205
3.3 Data Formats 213
3.4 Accessing Information 215
3.5 Arithmetic and Logical Operations 227
3.6 Control 236
3.7 Procedures 274
3.8 Array Allocation and Access 291
3.9 Heterogeneous Data Structures 301
3.10 Combining Control and Data in Machine-Level Programs 312
3.11 Floating-Point Code 329
3.12 Summary 345

\chapter{Processor Architecture}

387
4.1 The Y86-64 Instruction Set Architecture 391
4.2 Logic Design and the Hardware Control Language HCL 408
4.3 Sequential Y86-64 Implementations 420
4.4 General Principles of Pipelining 448
4.5 Pipelined Y86-64 Implementations 457
4.6 Summary 506
4.6.1 Y86-64 Simulators 508
Bibliographic Notes 509
Homework Problems 509
Solutions to Practice Problems 516


\include{section5}

\chapter{}
% 6
% The Memory Hierarchy 615
% 6.1 Storage Technologies 617
% 6.2 Locality 640
% 6.3 The Memory Hierarchy 645
% 6.4 Cache Memories 650
% 6.5 Writing Cache-Friendly Code 669
% 6.6 Putting It Together: The Impact of Caches on Program Performance 675
% 6.7 Summary 684
% Bibliographic Notes 684
% Homework Problems 685
% Solutions to Practice Problems 696


\part{ Running Programs on a System}


\include{section7}

% \chapter{Linking}

% 7.1 Compiler Drivers 707
% 7.2 Static Linking 708
% 7.3 Object Files 709
% 7.4 Relocatable Object Files 710
% 7.5 Symbols and Symbol Tables 711
% 7.6 Symbol Resolution 715
% 7.7 Relocation 725
% 7.8 Executable Object Files 731
% 7.9 Loading Executable Object Files 733
% 7.10 Dynamic Linking with Shared Libraries 734
% 7.11 Loading and Linking Shared Libraries from Applications 737
% 7.12 Position-Independent Code (PIC) 740
% 7.13 Library Interpositioning 743
% 7.14 Tools for Manipulating Object Files 749
% 7.15 Summary 749
% Bibliographic Notes 750
% Homework Problems 750
% Solutions to Practice Problems 753

\include{section8}


% --------------------------------------------------
% 8
% \chapter{Exceptional Control Flow}
% 8.1 Exceptions 759
% 8.1.1 Exception Handling 760
% 8.1.2 Classes of Exceptions 762
% 8.1.3 Exceptions in Linux/x86-64 Systems 765
% 8.2 Processes 768
% 8.2.1 Logical Control Flow 768
% 8.2.2 Concurrent Flows 769
% 8.2.3 Private Address Space 770
% 8.2.4 User and Kernel Modes 770
% 8.2.5 Context Switches 772
% 8.3 System Call Error Handling 773
% 8.4 Process Control 774
% 8.4.1 Obtaining Process IDs 775
% 8.4.2 Creating and Terminating Processes 775
% 8.4.3 Reaping Child Processes 779
% 8.4.4 Putting Processes to Sleep 785
% 8.4.5 Loading and Running Programs 786
% 8.4.6 Using fork and execve to Run Programs 789
% 8.5 Signals 792
% 8.5.1 Signal Terminology 794
% 8.5.2 Sending Signals 795
% 8.5.3 Receiving Signals 798
% 8.5.4 Blocking and Unblocking Signals 800
% 8.5.5 Writing Signal Handlers 802
% 8.5.6 Synchronizing Flows to Avoid Nasty Concurrency Bugs 812
% 8.5.7 Explicitly Waiting for Signals 814
% 8.6 Nonlocal Jumps 817
% 8.7 Tools for Manipulating Processes 822
% 8.8 Summary 823
% Bibliographic Notes 823
% Homework Problems 824
% Solutions to Practice Problems 831



% \chapter{Virtual Memory}

% 9.1 Physical and Virtual Addressing 839
% 9.2 Address Spaces 840
% 9.3 VM as a Tool for Caching 841
% 9.3.1 DRAM Cache Organization 842
% 9.3.2 Page Tables 842
% 9.3.3 Page Hits 844
% 9.3.4 Page Faults 844
% 9.3.5 Allocating Pages 846
% 9.3.6 Locality to the Rescue Again 846
% 9.4 VM as a Tool for Memory Management 847
% 9.5 VM as a Tool for Memory Protection 848
% 9.6 Address Translation 849
% 9.6.1 Integrating Caches and VM 853
% 9.6.2 Speeding Up Address Translation with a TLB 853
% 9.6.3 Multi-Level Page Tables 855
% 9.6.4 Putting It Together: End-to-End Address Translation 857
% 9.7 Case Study: The Intel Core i7/Linux Memory System 861
% 9.7.1 Core i7 Address Translation 862
% 9.7.2 Linux Virtual Memory System 864
% 9.8 Memory Mapping 869
% 9.8.1 Shared Objects Revisited 869
% 9.8.2 The fork Function Revisited 872
% 9.8.3 The execve Function Revisited 872
% 9.8.4 User-Level Memory Mapping with the mmap Function 873
% 9.9 Dynamic Memory Allocation 875
% 9.9.1 The malloc and free Functions 876
% 9.9.2 Why Dynamic Memory Allocation? 879
% 9.9.3 Allocator Requirements and Goals 880
% 9.9.4 Fragmentation 882
% 9.9.5 Implementation Issues 882
% 9.9.6 Implicit Free Lists 883
% 9.9.7 Placing Allocated Blocks 885
% 9.9.8 Splitting Free Blocks 885
% 9.9.9 Getting Additional Heap Memory 886
% 9.9.10 Coalescing Free Blocks 886
% 9.9.11 Coalescing with Boundary Tags 887
% 9.9.12 Putting It Together: Implementing a Simple Allocator 890
% 9.9.13 Explicit Free Lists 898
% 9.9.14 Segregated Free Lists 899
% 9.10 Garbage Collection 901
% 9.10.1 Garbage Collector Basics 902
% 9.10.2 Mark&Sweep Garbage Collectors 903
% 9.10.3 Conservative Mark&Sweep for C Programs 905
% 9.11 Common Memory-Related Bugs in C Programs 906
% 9.11.1 Dereferencing Bad Pointers 906
% 9.11.2 Reading Uninitialized Memory 907
% 9.11.3 Allowing Stack Buffer Overflows 907
% 9.11.4 Assuming That Pointers and the Objects They Point to
% Are the Same Size 908
% 9.11.5 Making Off-by-One Errors 908
% 9.11.6 Referencing a Pointer Instead of the Object It Points To 909
% 9.11.7 Misunderstanding Pointer Arithmetic 909
% 9.11.8 Referencing Nonexistent Variables 910
% 9.11.9 Referencing Data in Free Heap Blocks 910
% 9.11.10 Introducing Memory Leaks 911
% 9.12 Summary 911
% Bibliographic Notes 912
% Homework Problems 912
% Solutions to Practice Problems 916
% Part III Interaction and Communication
% between Programs


\part{ Interaction and Communication between Programs}




% \chapter{System-Level I/O}

% 10.1 Unix I/O 926
% 10.2 Files 927
% 10.3 Opening and Closing Files 929
% 10.4 Reading and Writing Files 931
% 10.5 Robust Reading and Writing with the Rio Package 933
% 10.5.1 Rio Unbuffered Input and Output Functions 933
% 10.5.2 Rio Buffered Input Functions 934
% 10.6 Reading File Metadata 939
% 10.7 Reading Directory Contents 941
% 10.8 Sharing Files 942
% 10.9 I/O Redirection 945
% 10.10 Standard I/O 947
% 10.11 Putting It Together: Which I/O Functions Should I Use? 947
% 10.12 Summary 949
% Bibliographic Notes 950
% Homework Problems 950
% Solutions to Practice Problems 951

% \chapter{Network Programming}
% 11.1 The Client-Server Programming Model 954
% 11.2 Networks 955
% 11.3 The Global IP Internet 960
% 11.3.1 IP Addresses 961
% 11.3.2 Internet Domain Names 963
% 11.3.3 Internet Connections 965
% 11.4 The Sockets Interface 968
% 11.4.1 Socket Address Structures 969
% 11.4.2 The socket Function 970
% 11.4.3 The connect Function 970
% 11.4.4 The bind Function 971
% 11.4.5 The listen Function 971
% 11.4.6 The accept Function 972
% 11.4.7 Host and Service Conversion 973
% 11.4.8 Helper Functions for the Sockets Interface 978
% 11.4.9 Example Echo Client and Server 980
% 11.5 Web Servers 984
% 11.5.1 Web Basics 984
% 11.5.2 Web Content 985
% 11.5.3 HTTP Transactions 986
% 11.5.4 Serving Dynamic Content 989
% 11.6 Putting It Together: The Tiny Web Server 992
% 11.7 Summary 1000
% Bibliographic Notes 1001
% Homework Problems 1001
% Solutions to Practice Problems 1002

% \chapter{Concurrent Programming}
% 12.1 Concurrent Programming with Processes 1009
% 12.1.1 A Concurrent Server Based on Processes 1010
% 12.1.2 Pros and Cons of Processes 1011
% 12.2 Concurrent Programming with I/O Multiplexing 1013
% 12.2.1 A Concurrent Event-Driven Server Based on I/O
% Multiplexing 1016
% 12.2.2 Pros and Cons of I/O Multiplexing 1021
% 12.3 Concurrent Programming with Threads 1021
% 12.3.1 Thread Execution Model 1022
% 12.3.2 Posix Threads 1023
% 12.3.3 Creating Threads 1024
% 12.3.4 Terminating Threads 1024
% 12.3.5 Reaping Terminated Threads 1025
% 12.3.6 Detaching Threads 1025
% 12.3.7 Initializing Threads 1026
% 12.3.8 A Concurrent Server Based on Threads 1027
% 12.4 Shared Variables in Threaded Programs 1028
% 12.4.1 Threads Memory Model 1029
% 12.4.2 Mapping Variables to Memory 1030
% 12.4.3 Shared Variables 1031
% 12.5 Synchronizing Threads with Semaphores 1031
% 12.5.1 Progress Graphs 1035
% 12.5.2 Semaphores 1037
% 12.5.3 Using Semaphores for Mutual Exclusion 1038
% 12.5.4 Using Semaphores to Schedule Shared Resources 1040
% 12.5.5 Putting It Together: A Concurrent Server Based on
% Prethreading 1044
% 12.6 Using Threads for Parallelism 1049
% 12.7 Other Concurrency Issues 1056
% 12.7.1 Thread Safety 1056
% 12.7.2 Reentrancy 1059
% 12.7.3 Using Existing Library Functions in Threaded Programs 1060
% 12.7.4 Races 1061
% 12.7.5 Deadlocks 1063
% 12.8 Summary 1066
% Bibliographic Notes 1066
% Homework Problems 1067
% Solutions to Practice Problems 1072

\end{document}