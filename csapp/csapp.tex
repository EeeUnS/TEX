
%\documentclass{report}
%\usepackage[cjk]{kotex}

\documentclass[chapter,oneside]{oblivoir}

%\usepackage{ikps,ansform}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{lipsum}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{ansform}
\usepackage{thmtools}
\usepackage{graphicx}
%https://www.overleaf.com/learn/latex/Inserting_Images

\usepackage{listings}
\usepackage{xcolor}
\declaretheoremstyle[% spaceabove=6pt,spacebelow=6pt, headfont=\color{MainColorOne}\sffamily\bfseries, notefont=\mdseries, notebraces={[}{]}, bodyfont=\normalfont,
headpunct={},
postheadspace=1em,
%qed=▣,
]{maintheorem}

\declaretheorem[%
name=정의,
style=maintheorem,
numberwithin=chapter, shaded={%bgcolor=MainColorThree!20,
margin=.5em}]{dfn}
% \begin{dfn}[]
% \end{dfn}

\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
%https://www.overleaf.com/learn/latex/Theorems_and_proofs

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
%https://tex.stackexchange.com/questions/348651/c-code-to-add-in-the-document
\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}



\begin{document}
    
    \title{EUnS's book}
    \author{ EUnS }

    \maketitle

    \tableofcontents



\chapter{A Tour of Computer Systems}


\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.3]{pic/pic1}
    \caption{The compilation system.}
\end{figure}

linux> gcc -o hello hello.c

컴파일 시스템을 이해해야하는 이유

\begin{enumerate}
    \item 성능 최적화
    \item 링커 에러 이해하기
    \item 보안 약점
\end{enumerate}


\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{pic/pic2}
    \caption{Hardware organization
    of a typical system. CPU:
    central processing unit,
    ALU: arithmetic/logic unit,
    PC: program counter, USB:
    Universal Serial Bus.}
\end{figure}


\begin{itemize}
    \item Buses
    
    하드웨어에 돌아다니는 데이터 통로(a collection of electrical conduits) word라고 하는 고정크기의 바이트 단위로 데이터가 전송된다. 최근에는 4byte 또는 8byte 크기를 가진다.

    \item I/O Devices
    시스템과 외부로부터의 연결을 가능케하는 장치.

    \item Main Memory
    
    프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 저장하는 임시 저장장치이다. 물리적으로 DRAM(Dynamic Random Access Memorry)로 구성되어 있다.

    \item Processor(CPU)
    
    프로그램 카운터(PC)는 메인메모리의 기계어 인스트럭션을 가리키는데 이 인스트럭션 값을 읽어서 특정한 동작을 수행하고 PC값을 갱신한다. 이 동작은 메인 메모리, 레지스터 파일, ALU주위를 돈다.
    레지스터 파일은 고유의 이름을 갖는 워드 크기의 레지스터 집합이다.
\end{itemize}

추가적인것 .

캐시

메모리 계층

쓰레드 동시성

프로세스 contex switching

가상메모리

파일

네트워크


\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{pic/pic3.png}
    \caption{메모리 계층}
\end{figure}



\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{pic/pic4.png}
    \caption{Layered view of a computer system.}
\end{figure}



\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{pic/pic5.png}
    \caption{Abstractions provided by an operating system.}
\end{figure}


\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.4]{pic/pic6.png}
    \caption{context switching}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{pic/pic7.png}
    \caption{Process virtual address space.}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.4]{pic/pic8.png}
    \caption{Using telnet to run hello remotely over a network.}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{pic/pic9.png}
    \caption{Multi-core processor organization. Four processor cores are integrated onto a single chip.}
\end{figure}


\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.3]{pic/pic10.png}
    \caption{Some abstractions provided by a computer system}
\end{figure}


%\chapter{Part I Program Structure and Execution}
\part{Part I Program Structure and Execution}

\chapter{Representing and Manipulating Information}


메모리에 객체가 저장되는 방식

객체의 수조는 사용된 바이트의 최소 주소로 정함.
4byte크기인 int type 변수 x가 주소 0x100로 설정된다면 $int \&x$의 값은 0x100이고 주소 0x100,1,2,0x103에 x가 저장된다.






\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.3]{pic/pic11.png}
    \caption{ex endian}
\end{figure}


\begin{itemize}
    \item little endian :  최하위 바이트를 시작주소에 차례로 저장하는 방식 (intel)
    \item big endian : 최상위 바이트를 시작주소에 차례로 저장하는 방식 (IBM Oracle)
\end{itemize}


\begin{lstlisting}[style = CStyle]
 #include <stdio.h>
 typedef unsigned char *byte_pointer;

 void show_bytes(byte_pointer start, size_t len) {
 int i;
 for (i = 0; i < len; i++)
 printf(" %.2x", start[i]);
 printf("\n");
 }

 void show_int(int x) {
 show_bytes((byte_pointer) &x, sizeof(int));
 }

 void show_float(float x) {
 show_bytes((byte_pointer) &x, sizeof(float));
 }

 void show_pointer(void *x) {
 show_bytes((byte_pointer) &x, sizeof(void *));
 }


 void test_show_bytes(int val) {
     int ival = val;
     float fval = (float) ival;
     int *pval = &ival;
     show_int(ival);
     show_float(fval);
     show_pointer(pval);
     }

\end{lstlisting}
서로 다른 컴퓨터 타입은 서로 다르고, 호환성이 없는 인스트럭션과 인코딩을 사용한다. 다른 운영체제를 실행하는 동일한 프로세서들도 각자의 코딩 관습에 차이가 잇으며, 따라서 이들은 바이너리 호환성을 갖지 못한다.

\begin{lstlisting}[style = CStyle]
    void inplace_swap(int *x, int *y) {
     *y = *x ^ *y; /* Step 1 */
     *x = *x ^ *y; /* Step 2 */
     *y = *x ^ *y; /* Step 3 */
     }
    \end{lstlisting}
    
    
    Shift Operations in C
    
    \begin{itemize}
        \item  논리(logical) 우측 쉬프트 : 좌측 끝을 k개의 0으로 채운다.
        \item  산출(arithmetic) 우측 쉬프트 : 좌측 끝을 k개의 1로 채운다.
    \end{itemize}
    
    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.4]{pic/shift}
    \end{figure}
    



\chapter{Machine-Level Representation of Programs}


linux> gcc -Og -o p p1.c p2.c


-0g 옵션 : 최적화 x

ISA (instruction set architectune)

linux> gcc -Og -S mstore.c

-S : 어셈블리 코드만 만든다 .s

linux> gcc -Og -c mstore.c

바이너리 형식 목적파일 .o  생성


linux> objdump -d mstore.o

disassembly


\section{x86 assembly}


\begin{figure}[h!]
    \centering
%    \includegraphics[scale=0.5]{pic/pic1}
    \caption{ward 0x1234567이 저장되는 방식.}
\end{figure}




\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{pic/pic1}
    \caption{ward 0x1234567이 저장되는 방식.}
\end{figure}





3.1 A Historical Perspective 202
3.2 Program Encodings 205
3.3 Data Formats 213
3.4 Accessing Information 215
3.5 Arithmetic and Logical Operations 227
3.6 Control 236
3.7 Procedures 274
3.8 Array Allocation and Access 291
3.9 Heterogeneous Data Structures 301
3.10 Combining Control and Data in Machine-Level Programs 312
3.11 Floating-Point Code 329
3.12 Summary 345

\chapter{Processor Architecture}

387
4.1 The Y86-64 Instruction Set Architecture 391
4.2 Logic Design and the Hardware Control Language HCL 408
4.3 Sequential Y86-64 Implementations 420
4.4 General Principles of Pipelining 448
4.5 Pipelined Y86-64 Implementations 457
4.6 Summary 506
4.6.1 Y86-64 Simulators 508
Bibliographic Notes 509
Homework Problems 509
Solutions to Practice Problems 516


\include{section5}



% \begin{figure}[h!]
%     \centering
%     \includegraphics[scale=0.5]{pic/pic1}
%     \caption{}
% \end{figure}

% \begin{lstlisting}[style = CStyle]
% \end{lstlisting}

% \begin{lstlisting}[style = CStyle]
% \end{lstlisting}

% \begin{lstlisting}[style = CStyle]
% \end{lstlisting}

% \begin{lstlisting}[style = CStyle]
% \end{lstlisting}

% \begin{lstlisting}[style = CStyle]
% \end{lstlisting}

% \begin{lstlisting}[style = CStyle]
% \end{lstlisting}


% 6
% The Memory Hierarchy 615
% 6.1 Storage Technologies 617
% 6.2 Locality 640
% 6.3 The Memory Hierarchy 645
% 6.4 Cache Memories 650
% 6.5 Writing Cache-Friendly Code 669
% 6.6 Putting It Together: The Impact of Caches on Program Performance 675
% 6.7 Summary 684
% Bibliographic Notes 684
% Homework Problems 685
% Solutions to Practice Problems 696



% \chapter{Part II Running Programs on a System}

% \chapter{Linking}

% 7.1 Compiler Drivers 707
% 7.2 Static Linking 708
% 7.3 Object Files 709
% 7.4 Relocatable Object Files 710
% 7.5 Symbols and Symbol Tables 711
% 7.6 Symbol Resolution 715
% 7.7 Relocation 725
% 7.8 Executable Object Files 731
% 7.9 Loading Executable Object Files 733
% 7.10 Dynamic Linking with Shared Libraries 734
% 7.11 Loading and Linking Shared Libraries from Applications 737
% 7.12 Position-Independent Code (PIC) 740
% 7.13 Library Interpositioning 743
% 7.14 Tools for Manipulating Object Files 749
% 7.15 Summary 749
% Bibliographic Notes 750
% Homework Problems 750
% Solutions to Practice Problems 753


% Linker

% 7.1 .c-> .i -> .s -> .o ->(linker) exe

% ​

% ​

% 7.2 static linker

% ​

% 순서

% 1.symbol resolution(7.6)

% 2. Relocation(7.7)

% ​

% 7.3 object file(object module)

% 1. Relocatable ob~(7.4)

% 2.Executable ob~(7.8,7.9)

% 3.shared ob~ (7.10)

% ​

% 7.5 symbol & symbol table(.symtab chapter)

% ​

% 1. 전역(definition)

% 2. 전역(Reference)

% 3. 지역(locale),static -> table X

% ​

% ​

% ​

% 7.6 symbol resolution

% ​

% 1.chapter,symbol def Relocation

% 2.in chapter symbol ref ''

% ​

% ​

% 7.7 Relocation

% ​

% -o ,-o-> .a

% 규칙 : 중복 symbol 처리

% 1. 복수의 강한 symbol(초기화된 전역) -> compiler error

% 2. 강 > 약(초기화 X 전역)

% 3. 약s->아무거나

% + static lib

% ​

% 7.8,7.9 Executable ob~

% ​

% ​

% 7.10,7.11

% DLL, .so 






% --------------------------------------------------
% 8
% \chapter{Exceptional Control Flow}
% 8.1 Exceptions 759
% 8.1.1 Exception Handling 760
% 8.1.2 Classes of Exceptions 762
% 8.1.3 Exceptions in Linux/x86-64 Systems 765
% 8.2 Processes 768
% 8.2.1 Logical Control Flow 768
% 8.2.2 Concurrent Flows 769
% 8.2.3 Private Address Space 770
% 8.2.4 User and Kernel Modes 770
% 8.2.5 Context Switches 772
% 8.3 System Call Error Handling 773
% 8.4 Process Control 774
% 8.4.1 Obtaining Process IDs 775
% 8.4.2 Creating and Terminating Processes 775
% 8.4.3 Reaping Child Processes 779
% 8.4.4 Putting Processes to Sleep 785
% 8.4.5 Loading and Running Programs 786
% 8.4.6 Using fork and execve to Run Programs 789
% 8.5 Signals 792
% 8.5.1 Signal Terminology 794
% 8.5.2 Sending Signals 795
% 8.5.3 Receiving Signals 798
% 8.5.4 Blocking and Unblocking Signals 800
% 8.5.5 Writing Signal Handlers 802
% 8.5.6 Synchronizing Flows to Avoid Nasty Concurrency Bugs 812
% 8.5.7 Explicitly Waiting for Signals 814
% 8.6 Nonlocal Jumps 817
% 8.7 Tools for Manipulating Processes 822
% 8.8 Summary 823
% Bibliographic Notes 823
% Homework Problems 824
% Solutions to Practice Problems 831


% \chapter{Virtual Memory}

% 9.1 Physical and Virtual Addressing 839
% 9.2 Address Spaces 840
% 9.3 VM as a Tool for Caching 841
% 9.3.1 DRAM Cache Organization 842
% 9.3.2 Page Tables 842
% 9.3.3 Page Hits 844
% 9.3.4 Page Faults 844
% 9.3.5 Allocating Pages 846
% 9.3.6 Locality to the Rescue Again 846
% 9.4 VM as a Tool for Memory Management 847
% 9.5 VM as a Tool for Memory Protection 848
% 9.6 Address Translation 849
% 9.6.1 Integrating Caches and VM 853
% 9.6.2 Speeding Up Address Translation with a TLB 853
% 9.6.3 Multi-Level Page Tables 855
% 9.6.4 Putting It Together: End-to-End Address Translation 857
% 9.7 Case Study: The Intel Core i7/Linux Memory System 861
% 9.7.1 Core i7 Address Translation 862
% 9.7.2 Linux Virtual Memory System 864
% 9.8 Memory Mapping 869
% 9.8.1 Shared Objects Revisited 869
% 9.8.2 The fork Function Revisited 872
% 9.8.3 The execve Function Revisited 872
% 9.8.4 User-Level Memory Mapping with the mmap Function 873
% 9.9 Dynamic Memory Allocation 875
% 9.9.1 The malloc and free Functions 876
% 9.9.2 Why Dynamic Memory Allocation? 879
% 9.9.3 Allocator Requirements and Goals 880
% 9.9.4 Fragmentation 882
% 9.9.5 Implementation Issues 882
% 9.9.6 Implicit Free Lists 883
% 9.9.7 Placing Allocated Blocks 885
% 9.9.8 Splitting Free Blocks 885
% 9.9.9 Getting Additional Heap Memory 886
% 9.9.10 Coalescing Free Blocks 886
% 9.9.11 Coalescing with Boundary Tags 887
% 9.9.12 Putting It Together: Implementing a Simple Allocator 890
% 9.9.13 Explicit Free Lists 898
% 9.9.14 Segregated Free Lists 899
% 9.10 Garbage Collection 901
% 9.10.1 Garbage Collector Basics 902
% 9.10.2 Mark&Sweep Garbage Collectors 903
% 9.10.3 Conservative Mark&Sweep for C Programs 905
% 9.11 Common Memory-Related Bugs in C Programs 906
% 9.11.1 Dereferencing Bad Pointers 906
% 9.11.2 Reading Uninitialized Memory 907
% 9.11.3 Allowing Stack Buffer Overflows 907
% 9.11.4 Assuming That Pointers and the Objects They Point to
% Are the Same Size 908
% 9.11.5 Making Off-by-One Errors 908
% 9.11.6 Referencing a Pointer Instead of the Object It Points To 909
% 9.11.7 Misunderstanding Pointer Arithmetic 909
% 9.11.8 Referencing Nonexistent Variables 910
% 9.11.9 Referencing Data in Free Heap Blocks 910
% 9.11.10 Introducing Memory Leaks 911
% 9.12 Summary 911
% Bibliographic Notes 912
% Homework Problems 912
% Solutions to Practice Problems 916
% Part III Interaction and Communication
% between Programs

% \chapter{System-Level I/O}

% 10.1 Unix I/O 926
% 10.2 Files 927
% 10.3 Opening and Closing Files 929
% 10.4 Reading and Writing Files 931
% 10.5 Robust Reading and Writing with the Rio Package 933
% 10.5.1 Rio Unbuffered Input and Output Functions 933
% 10.5.2 Rio Buffered Input Functions 934
% 10.6 Reading File Metadata 939
% 10.7 Reading Directory Contents 941
% 10.8 Sharing Files 942
% 10.9 I/O Redirection 945
% 10.10 Standard I/O 947
% 10.11 Putting It Together: Which I/O Functions Should I Use? 947
% 10.12 Summary 949
% Bibliographic Notes 950
% Homework Problems 950
% Solutions to Practice Problems 951

% \chapter{Network Programming}
% 11.1 The Client-Server Programming Model 954
% 11.2 Networks 955
% 11.3 The Global IP Internet 960
% 11.3.1 IP Addresses 961
% 11.3.2 Internet Domain Names 963
% 11.3.3 Internet Connections 965
% 11.4 The Sockets Interface 968
% 11.4.1 Socket Address Structures 969
% 11.4.2 The socket Function 970
% 11.4.3 The connect Function 970
% 11.4.4 The bind Function 971
% 11.4.5 The listen Function 971
% 11.4.6 The accept Function 972
% 11.4.7 Host and Service Conversion 973
% 11.4.8 Helper Functions for the Sockets Interface 978
% 11.4.9 Example Echo Client and Server 980
% 11.5 Web Servers 984
% 11.5.1 Web Basics 984
% 11.5.2 Web Content 985
% 11.5.3 HTTP Transactions 986
% 11.5.4 Serving Dynamic Content 989
% 11.6 Putting It Together: The Tiny Web Server 992
% 11.7 Summary 1000
% Bibliographic Notes 1001
% Homework Problems 1001
% Solutions to Practice Problems 1002

% \chapter{Concurrent Programming}
% 12.1 Concurrent Programming with Processes 1009
% 12.1.1 A Concurrent Server Based on Processes 1010
% 12.1.2 Pros and Cons of Processes 1011
% 12.2 Concurrent Programming with I/O Multiplexing 1013
% 12.2.1 A Concurrent Event-Driven Server Based on I/O
% Multiplexing 1016
% 12.2.2 Pros and Cons of I/O Multiplexing 1021
% 12.3 Concurrent Programming with Threads 1021
% 12.3.1 Thread Execution Model 1022
% 12.3.2 Posix Threads 1023
% 12.3.3 Creating Threads 1024
% 12.3.4 Terminating Threads 1024
% 12.3.5 Reaping Terminated Threads 1025
% 12.3.6 Detaching Threads 1025
% 12.3.7 Initializing Threads 1026
% 12.3.8 A Concurrent Server Based on Threads 1027
% 12.4 Shared Variables in Threaded Programs 1028
% 12.4.1 Threads Memory Model 1029
% 12.4.2 Mapping Variables to Memory 1030
% 12.4.3 Shared Variables 1031
% 12.5 Synchronizing Threads with Semaphores 1031
% 12.5.1 Progress Graphs 1035
% 12.5.2 Semaphores 1037
% 12.5.3 Using Semaphores for Mutual Exclusion 1038
% 12.5.4 Using Semaphores to Schedule Shared Resources 1040
% 12.5.5 Putting It Together: A Concurrent Server Based on
% Prethreading 1044
% 12.6 Using Threads for Parallelism 1049
% 12.7 Other Concurrency Issues 1056
% 12.7.1 Thread Safety 1056
% 12.7.2 Reentrancy 1059
% 12.7.3 Using Existing Library Functions in Threaded Programs 1060
% 12.7.4 Races 1061
% 12.7.5 Deadlocks 1063
% 12.8 Summary 1066
% Bibliographic Notes 1066
% Homework Problems 1067
% Solutions to Practice Problems 1072

\end{document}