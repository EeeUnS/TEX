\documentclass{oblivoir}




\title{all about Quick Sort}
\author{이윤승}

\begin{document}
    

\maketitle

\section{소개}

\begin{itemize}
    \item 일반적으로 가장 많이 사용하는 정렬 알고리즘
    \item 비교 정렬
    \item 내부정렬
    \item 불안정 정렬
    \item 평균 복잡도: $O(n \lg n)$
    \item 최악의 복잡도 : $O(n^2)$
    \item C++ std::sort의 내부구현이 퀵소트로 되어있음
\end{itemize}

\section{의사코드 및 동작}

분할 정복(divide and conquer) 방법을 통해 설계 되었음


QUICKSORT(A,p,r)
    if p < r
        q = PARTITION(A,p,r)
        QUICKSORT(A,p,q-1)
        QUICKSORT(A,q+1,r)


PARTITION(A ,p ,r)
    x= A[r]
    i = p-1
    for j = p to r-1
        if A[j]<= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i+1] with A[r]
    return i + 1


성능 참고

https://www.acmicpc.net/blog/view/58


복잡도 분석

최악의 복잡도 : 최악의 경우 분할 케이스를 생각해보자 
이는 왼쪽 오른쪽 분할이 한쪽으로 쏠려(오름차순,내림차순) 극도로 불균형하게 일어났을때이다.
피봇값에 의한 분할이 아예 일어나지 않을 때 최악의 케이스가 된다.
이때 재귀함수는 
$$T(n) = T(n-1) + \Theta(n)$$이다.
따라서 시간복잡도는 $\Theta(n^2)$이다.

최선의 복잡도 : 정확하게 반으로 나누어 졌을때 최선의 분할 케이스이다.
이때의 재귀함수는
$$T(n) = 2T(n/2) + \Theta(n)$$
이다.

따라서 시간복잡도는 $\Theta(n \lg n)$이다.(마스터정리 경우2)

$\Theta(n \lg n)$


평균복잡도 : $O(n \lg n)$


직관적인 방법 : 


수식 : $O(n \lg n)$


여러 기초 지식



상한 

하한


확률


기타증명






\begin{thebibliography}{}
    \bibitem{reference1}
    Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7.
\end{thebibliography}
    


\end{document}
